<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - Stanislav Sotnikov</title>
        <link>https://stansotn.github.io/posts/</link>
        <description>All Posts | Stanislav Sotnikov</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>stanislav.sotnikov145@gmail.com (Stanislav Sotnikov)</managingEditor>
            <webMaster>stanislav.sotnikov145@gmail.com (Stanislav Sotnikov)</webMaster><lastBuildDate>Sun, 10 Oct 2021 18:00:00 -0500</lastBuildDate><atom:link href="https://stansotn.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Reverse SSH over Websocket</title>
    <link>https://stansotn.github.io/ssh_websocket_proxy/</link>
    <pubDate>Sun, 10 Oct 2021 18:00:00 -0500</pubDate>
    <author>Author</author>
    <guid>https://stansotn.github.io/ssh_websocket_proxy/</guid>
    <description><![CDATA[Sometimes you might find yourself in dark places where ssh is not allowed, and you must find a way to communicate with the outer world with something other than HTTP/HTTPS. Why would they do it in the first place, you might be asking. Sshing into the outer world is 0 steps away from sshing inwards. Meaning if there is a way out, there is always a way in. Reverse ssh duh!]]></description>
</item><item>
    <title>Your Very Own Remote Linux Box</title>
    <link>https://stansotn.github.io/linux_box/</link>
    <pubDate>Wed, 06 Oct 2021 17:00:49 -0500</pubDate>
    <author>Author</author>
    <guid>https://stansotn.github.io/linux_box/</guid>
    <description><![CDATA[Every time I installed a fresh linux box, I would find myself looking up the same series of commands over and over to make the newly spawned machine distinct and securely accessible on the network.
Then I7600 IoT Design Lab at CCNY incentivized me to write this tutorial for academic credit.
1. Requirements The instructions below are typeset as I am handling ubuntu 20.04 64bit server installation on a raspberry pi, though this tutorial should work with other devices and linux flavors.]]></description>
</item><item>
    <title>Embedded Debugging</title>
    <link>https://stansotn.github.io/embedded_debugging/</link>
    <pubDate>Thu, 26 Nov 2020 17:00:49 -0500</pubDate>
    <author>Author</author>
    <guid>https://stansotn.github.io/embedded_debugging/</guid>
    <description><![CDATA[Continuing the saga on embedded development, this post goes over common ways to debug bare metal ARM, illustrating the technique on blue pill (aka stm32f103c8t6) and most common debugger probes.
The debugger itself is a physical piece of hardware that lives inside the processor and can take control of the cpu and memories. When it comes to ARM, there are two protocols available to interface the on chip debugger &ndash; JTAG and Serial Wire Debug or swd (more about the differences here).]]></description>
</item><item>
    <title>Embedded Environment</title>
    <link>https://stansotn.github.io/embedded_environment/</link>
    <pubDate>Sun, 22 Nov 2020 17:00:49 -0500</pubDate>
    <author>Author</author>
    <guid>https://stansotn.github.io/embedded_environment/</guid>
    <description><![CDATA[Have you ever wondered what is going on behind the mystical IDE of your embedded choice?
Many programming journeys start with learning user interface of a particular Development Environment &ndash; a path I took myself. While IDEs can arguably simplify things, various knobs get defaulted to some magic values. Unless you know upfront, it can be tricky to lookup what these radio buttons actually do.
There is a plethora of bare-metal oriented Integrated Development Environments (IDEs) in the wild sharing a similar set of features.]]></description>
</item></channel>
</rss>
