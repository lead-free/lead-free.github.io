[{"categories":null,"content":"Sometimes you might find yourself in dark places where ssh is not allowed, and you must find a way to communicate with the outer world with something other than HTTP/HTTPS. Why would they do it in the first place, you might be asking. Sshing into the outer world is 0 steps away from sshing inwards. Meaning if there is a way out, there is always a way in. Reverse ssh duh! Once upon a blue moon, my comrades and I were sent to work from home for reasons well known, leaving us away from the computational capacities and free electricity. Colleagues were divided into two categories, the ones who used remote desktop apps, and the ones who used reverse ssh. At that point inward ssh was already blocked. We have attempted the civilized path as we were pending for the mystical and perhaps non-existing vpn access to our organization. Their firewalls blocked all remote desktop apps, and then some 6 month later all outgoing ssh connections went down as well (so did reverse ssh). The curious reader is aware – regardless of the hardware, service, or encoding, connect it to the internet and someone’s gonna own it (credit to dual core). ","date":"2021-10-10","objectID":"/ssh_websocket_proxy/:0:0","tags":null,"title":"Reverse SSH over Websocket","uri":"/ssh_websocket_proxy/"},{"categories":null,"content":"1. Requirements A captive machine we want to set free. Open SSH installed, no root permissions required. A machine in the demilitarized zone. Must be always up and running. Could be at your house or in the cloud. Further, referred as free server. Access to both free and captive servers to set things up. Websocat. Binaries available for unix-like x86 systems. Builds painlessly on ARM (build guide in the repo). Open SSH client and server on both free and captive servers. Open SSL command line tool on the free server. ","date":"2021-10-10","objectID":"/ssh_websocket_proxy/:1:0","tags":null,"title":"Reverse SSH over Websocket","uri":"/ssh_websocket_proxy/"},{"categories":null,"content":"2. Free Server 2.1 Generating Certificate First, we have to set up a certificate to encrypt the websocket connection. Firewalls I encountered restrict outgoing ssh connections by sniffing the ssh version header, which gets transmitted unencrypted at the initial handshake. This method won’t help you if your websocket communication is plaintext. Generate the certificate on the free server. openssl req -x509 -newkey rsa:4096 -keyout wss-key.pem -out wss-cert.pem -days 365 --nodes In case you have openssl ^v3.0, I would recommend using dsa key. The command would be. openssl req -x509 -newkey dsa -keyout wss-key.pem -out wss-cert.pem -days 365 --noenc Either command would spit out a private key and a certificate. Hint: the second ’s' stands for secure. Bundle the private key and the certificate into an archive to feed to websocat. openssl pkcs12 -export -out wss.pkcs12 -inkey wss-key.pem -in wss-cert.pem 2.2 Persistent Websocat Time to set up websocat. We would like to make our free server persistent, so that if the machine reboots, the server program comes back online automagically. Below is a simple shell script to start a websocat server on port 1337 that decrypts and redirects all traffic into localhost:22 (aka ssh) in binary form. In addition, output of websocat is logged for further debugging if needed. I will further refer to the following shell script as wss-server.sh # Content of `wss-server.sh` # Path to websocat executable websocat=~/websocat # Path to certificate bundle pkcs12=~/wss.pkcs12 # Log file (optional) log=~/websocat.log echo \"Websocat server starting on $(date)\" \u003e\u003e $log $websocat --binary wss-l:127.0.0.1:1337 tcp:127.0.0.1:22 --pkcs12-der $pkcs12 \u003e\u003e $log 2\u003e\u00261 websocat itself is quite reliable – I’ve been running it for months without restarting the process, but your free server might not be, as your roommate reaches to restart the router because they think it could fix their laggy bloated laptop and by accident your raspberry pi gets unplugged. It’s a good thing raspberry pi boots by itself when the power is back. Let’s make our websocket server to do the same. This can be achieved by adding wss-server.sh to crontab. Open crontab file. crontab -l Add the following line substituting your path to wss-server.sh. @reboot ~/.local/bin/wss-server.sh The websocat server will start on boot. It’s worth to try running wss-server.sh from the command line before restarting. ","date":"2021-10-10","objectID":"/ssh_websocket_proxy/:2:0","tags":null,"title":"Reverse SSH over Websocket","uri":"/ssh_websocket_proxy/"},{"categories":null,"content":"3. Captive Server Here I will skip the steps of generating a keypair for securing your ssh connection, you can find a step-by-step guide here (note, this needs to be done for both machines). First download the latest release of websocat for your system from here. wget url/to/the/download/link Set up ssh proxy. The following to be added into ~/.ssh/config. host ws.freeserver User username ProxyCommand ~/websocat --binary wss://\u003cip or hostname of free server\u003e --insecure IdentityFile ~/.ssh/captive-private-key The --insecure flag is set here to disable TLS certificate validation with trusted certificate authorities. The encryption is used in the websocket layer of communication to make it non-trivial for the firewall to filter your packets. Rely on ssh encryption for security. If for whatever reason you want to use verifiable certificate, you can get one for free from let’s encrypt. Note, then you would have to use appropriate certificate bundle on the free server. Now you can ssh into the free server from the captive server. ssh ws.freeserver If you’d like to leave a backdoor to be able to access the captive server from anywhere on the internet you can use a reverse ssh configuration. The following command mounts port 22 of the captive server to port 1338 of the free server. A good explanation of what ssh forwarding does can be found here ssh -R 1338:localhost:22 ws.freeserver You can now ssh into the captive server as you would normally ssh into the free server, just specify the port. # Will get you into the *captive server* ssh freeserver -p 1338 To run the above-mentioned command in the background, add -N -f flags. SSH connection has a tendency of dropping, use autossh to keep the connection alive (you might have to download the widely available executable). Add the following to crontab if you’d like to start the ssh tunnel on every boot. @reboot autossh -NRf 1338:localhost:22 ws.freeserver ","date":"2021-10-10","objectID":"/ssh_websocket_proxy/:3:0","tags":null,"title":"Reverse SSH over Websocket","uri":"/ssh_websocket_proxy/"},{"categories":null,"content":"4. Afterword Did you know you could use ssh as poor man’s vpn, for instance, you can browse the internet from anywhere as if you were browsing from the captive server, see sshuttle. In case your ip is blacklisted by the captive’s firewall, you can set up dns record and proxy for on cloudflare for free. In case you would like nginx to proxy connections at the free server with uri path resolution, here is an example configuration to proxy websocket connections with nginx. server { listen 443 ssl; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; proxy_pass https://localhost:1337; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"Upgrade\"; proxy_read_timeout 1000; proxy_ssl_certificate /path/to/cert.pem; proxy_ssl_certificate_key /path/to/key.pem; } } Help Me Improve I am learning to write meaningful documentation. I hope you enjoyed this post, please help me back by emailing some feedback! Is information clear, correct and up to date? How would you improve this post? ","date":"2021-10-10","objectID":"/ssh_websocket_proxy/:4:0","tags":null,"title":"Reverse SSH over Websocket","uri":"/ssh_websocket_proxy/"},{"categories":null,"content":"Every time I installed a fresh linux box, I would find myself looking up the same series of commands over and over to make the newly spawned machine distinct and securely accessible on the network. Then I7600 IoT Design Lab at CCNY incentivized me to write this tutorial for academic credit. ","date":"2021-10-06","objectID":"/linux_box/:0:0","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"1. Requirements The instructions below are typeset as I am handling ubuntu 20.04 64bit server installation on a raspberry pi, though this tutorial should work with other devices and linux flavors. The only requirement is a freshly installed linux box (further referred as remote) that we are about to boot into and a wired connection to a DHCP network, so that we can find our box on the network from the computer we are about to ssh from (further referred as local). This tutorial leaves the process of linux installation up to you. ","date":"2021-10-06","objectID":"/linux_box/:1:0","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"2. First Boot Our device is powered on, let’s map it on the network. ","date":"2021-10-06","objectID":"/linux_box/:2:0","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"2.1 You own the network. In case you own the network and have access the router/network switch you can look up the ip address of the device on your NAT. Ubuntu device will be called ubuntu by default. Keep in mind that the ip address will change when DHCP lease time is over, most of the routers have an option to make the ip address sticky. ","date":"2021-10-06","objectID":"/linux_box/:2:1","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"2.2 The network isn’t yours This might get tricky since you can’t simply determine the ip of your newly installed ubuntu box. First you have to be sure that the network switch you are connecting to is DHCP (the ip address can be obtained automatically), you could poke the ethernet port with your laptop to test. Now you’d like to determine the ip address of your box. You could run a network scan with nmap to discover devices on the subnet. nmap -sn 192.168.1.0/24 # if your ip is 192.168.1.x In case nmap resolved hostnames (you’re lucky), just look for ubuntu in the list. Otherwise, you might have to unplug your device’s ethernet and do another scan to see which device disappeared/appeared. ","date":"2021-10-06","objectID":"/linux_box/:2:2","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"3. Changing defaults Once you have determined the ip, it is time to remotely login via ssh. ssh ubuntu@192.168.0.123 # Relace the ip of your device. You will be prompted to enter the default password (it’s ubuntu in case you are working with ubuntu). Next, we would like to change the device hostname (as it appears on the network) and username, which would require log in as a different user. We will login as root. Alternatively we could create another user account and then delete the default one. In this tutorial I will use the root account. Set root password. sudo passwd root Open sshd_config and allow login as root by setting PermitRootLogin yes. sudo nano /etc/ssh/sshd_config # Open sshd_config Restart ssh service. service sshd restart Logout. exit ","date":"2021-10-06","objectID":"/linux_box/:3:0","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"3.1 Change hostname Login as root. ssh root@192.168.0.123 # Relace the ip of your device. Hostname is a string that device uses to self identify on the network, it is stored in /etc/hostname. If you read the file you can see the default “ubuntu” in there. My device is a raspberry pi 3b, and I shall set hostname accordingly (so I can recognize it from the other devices on my local network). echo \"raspi3b-alpha\" \u003e /etc/hostname ","date":"2021-10-06","objectID":"/linux_box/:3:1","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"3.2 Change username Rename the default ubuntu user. usermod -l my_username -d /home/my_username -m ubuntu Reboot. reboot ","date":"2021-10-06","objectID":"/linux_box/:3:2","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"4. Public key authentication If you don’t have a key pair associated with your local machine, create one. cd ~/.ssh # SSH keys are normally stored in the .ssh directory. ssh-keygen -t ed25519 You will be prompted to enter the key name and protect it with a password (up to you). This will generate your-key.pub and your-key, public and private keys accordingly. Public key is the one you will share with remotes, private key should stay safe and secret on you local computer. Share public key with the remote. scp your-key.pub my_username@192.168.0.123:~/.ssh/. # Mind the ip. ","date":"2021-10-06","objectID":"/linux_box/:4:0","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"4.1 Secure the remote Login to the remote. ssh my_username@192.168.0.123 Authorize your-key.pub to be a login credential on the remote. cat ~/.ssh/your-key.pub \u003e\u003e ~/.ssh/authorized_keys Configure ssh by finding and setting the following in the /etc/ssh/sshd_config PermitRootLogin no # disable root login PubkeyAuthentication yes # enable public key authentication. PasswordAuthentication no # disable password authentication. Hint: press ctrl+w and type something to search. sudo nano /etc/ssh/sshd_config # open sshd_config with nano Finally, restart ssh to apply the changes. service sshd restart Almost forgot, lock the root user. sudo passwd -l root Attempt to log in using public key from your local machine. Notice, flag -i is pointing to the private key. Attempting to log in without passing the public key should now fail. ssh my_username@192.168.0.123 -i ~/.ssh/your-key ","date":"2021-10-06","objectID":"/linux_box/:4:1","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"5. Tips and tricks ","date":"2021-10-06","objectID":"/linux_box/:5:0","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"5.1. SSH config Imagine you would like to manage multiple devices from your local machine. Remembering all ip addresses specifying path to the appropriate keys can get annoying quickly. You could add the following directive to you local ~/.ssh/config. Host raspi3b.local # Name of the entry HostName 192.168.0.123 # This can also be a dns name like `my-domain.com`. User my_username # Your username goes here. IdentityFile ~/.ssh/your-key # Path to your private key. This way you could just type the following to login. ssh raspi3b.local In case you’re wondering the .local is just my way of indication that I would like to login via the local network. You could set the name to anything. Help Me Improve I am learning to write meaningful documentation. I hope you enjoyed this post, please help me back by emailing some feedback! Is information clear, correct and up to date? How would you improve this post? ","date":"2021-10-06","objectID":"/linux_box/:5:1","tags":null,"title":"Your Very Own Remote Linux Box","uri":"/linux_box/"},{"categories":null,"content":"Continuing the saga on embedded development, this post goes over common ways to debug bare metal ARM, illustrating the technique on blue pill (aka stm32f103c8t6) and most common debugger probes. The debugger itself is a physical piece of hardware that lives inside the processor and can take control of the cpu and memories. When it comes to ARM, there are two protocols available to interface the on chip debugger – JTAG and Serial Wire Debug or swd (more about the differences here). In this tutorial we will focus on swd, which our blue pill has a pinout for. Apart from the pin count the two interfaces are very similar. ","date":"2020-11-26","objectID":"/embedded_debugging/:0:0","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"1. Probes To use the available swd (or jtag) interface you would need a debugger probe and a driver that understands how to talk both to the probe and to the gnu debugger instance (further referred as gdb). Let’s call this driver connector program a gdbserver. This tutorial shines some light on using Open On Chip Debugger or openocd as a gdbserver and its alternatives. To be clear gdbserver and gdb are different programs: gdbserver – the driver program that employs the debugger probe, communicates to the outer world via tcp. gdb – the client program that loads the executable and interacts with the user (i.e. set breakpoints). ","date":"2020-11-26","objectID":"/embedded_debugging/:1:0","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"1.1 Raspberry Pi Any raspberry pi on its own can serve as a debugger probe thanks to the spi driver for openocd developed by lupyuen. This is amazing because there is no need for external debugger probe, making embedded development more accessible to broke students like myself. Chances are you have a raspberry pi collecting dust and you don’t have a dedicated debugger hardware (like jlink or stlink). Important to notice, because gdbserver talks to the gdb instance via tcp, you can sit back and enjoy the development process (both building and debugging) from an external computer on the network, that is you don’t have to develop code on the raspberry pi itself. ","date":"2020-11-26","objectID":"/embedded_debugging/:1:1","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"1.2 stlink An increasingly common probe. stlinks are being included with almost every st’s official evaluation board, where besides being a debugger they are also used as a usb to serial converter. As you may have noticed, blue pill does not include an stlink, the on board micro usb receptacle is connected directly to the stm32f103’s on chip usb peripheral. An external stlink-v3 mini is a tiny, inexpensive and yet powerful debugger. In addition to swd and jtag, it is capable of usb to spi, i2c, can, and gpio interface via a public c++ api stlink-v3-bridge. The main disadvantage of stlink is that there is no straight forward way to run a compatible gdbserver. For some reason STMicroelectronics does not distribute a gdbserver for stlink as an executable binary as of today, even though gdbserver binaries are included with the STMCube IDE and with little effort can be scrapped from the IDE package (see 2.2.4). From a conversation with an ST developer, turns out their gdbserver is a modified version of openocd publicly developed here and in future might be merged with the original openocd branch. ","date":"2020-11-26","objectID":"/embedded_debugging/:1:2","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"1.3 jlink A royal plug and play probe with official gdbserver binaries available for a wide variety of architectures including raspberry pi. The best choice if you do not have time to grasp openocd and have funds to get the probe. ","date":"2020-11-26","objectID":"/embedded_debugging/:1:3","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"2. gdbserver Pick your probe and see what are the options of getting a gdbserver running. ","date":"2020-11-26","objectID":"/embedded_debugging/:2:0","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"2.1. openocd + Raspberry Pi Openocd must be built from source to enable swd over spi capability on any raspberry pi. A glance at history; openocd capabilities to make use of the raspberry pi’s spi port were developed in this fork, which to the day of writing this post had not been merged into the original opencod repo. The author of the spi tweak published this article on how to get the hack working with Rust and nrf52, beware this only works on a 32 bit raspbian. With appearance of 64 bit Ubuntu for raspberry pi, a pull request added aarch64 support. The latter is the particular version of openocd that I tested on raspberry pi, it works both on aarch32 raspbian and aarch64 ubuntu. sudo apt install autoconf libtool libusb-1.0-0 libusb-1.0-0-dev git clone --recursive https://github.com/jeliebig/openocd-spi cd openocd-spi ./bootstrap ./configure --enable-bcm2835spi make Feel free to grab some coffee, the build process can take a while. Upon success you will find an openocd binary in the src/ folder. Raspbery pi’s spi is disabled by default. Enable spi by writing dtparam=spi=on to /boot/config.txt in Raspbian or /boot/firmware/usercfg.txt in Ubuntu. Reboot. Then, enable read write access to spi port. sudo chmod 606 /dev/spidev0.0 Create an openocd configuration file. # file: swd-pi.ocd # OpenOCD script for using Raspberry Pi as SWD Programmer for stm32f1x # Select the Broadcom SPI interface for Raspberry Pi (SWD transport) interface bcm2835spi # Set the SPI speed in kHz bcm2835spi_speed 31200 # 31.2 MHz # Select stm32f1xx as target source [find target/stm32f1x.cfg] # Open gdbserver to the network. bindto 0.0.0.0 Connect the blue pill. blue pill raspi swdio pin 19 swdclk pin 23 gnd gnd Power up the blue pill. Despite being very convenient, I would not recommend powering the pill from pi’s 3.3V line as if you short something on the pill, raspberry will die. If you supply the power through micro usb or 5V line you will likely to kill the pill’s linear voltage regulator in case something gets shorted. Run openocd. Argument -s ../tcl/ is a path to the tlc folder where openocd looks for configuration files; argument -f swd-pi.ocd points to the session specific configuration we just created. # From openocd-spi/src ./openocd -s ~/projects/openocd-spi/tcl/ -f swd-pi.ocd Upon success you shall see an output containing Info : BCM2835 SPI SWD driver Info : SWD only mode enabled Info : clock speed 31200 kHz Info : SWD DPIDR 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints Info : Listening on port 3333 for gdb connections In case you see Info : SWD DPIDR 0x0000ffff openocd failed to connect to the microcontroller, check connection. In case you see the following being endlessly printed spi_transmit failed: Bad file descriptor Then either spi is disabled or openocd does not have permissions to /dev/spidev0.0. Odds are you can’t ctrl+c yourself out of the error, then you need to find and kill the process from a different window. pgrep openocd # Lookup process id. kill -9 \u003cprocess id\u003e # Kill openocd process. ","date":"2020-11-26","objectID":"/embedded_debugging/:2:1","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"2.2. openocd + stlink Getting stlink to cooperate is pretty much about getting openocd to work on your system one way or the other. Let’s start with a configuration file for stlink and stm32fxx as it will be the same for any host. # file: stlink-swd.ocd # Select stlink probe source [find interface/stlink.cfg] # Select stm32f1xx as target source [find target/stm32f1x.cfg] # Select swd transport select hla_swd # Open gdbserver to the network. bindto 0.0.0.0 You may notice that openocd is available in a package manager apt or brew, but the version you will get is very outdated (0.1 as of today) and will not support stlink-v3 even if you import a proper interface configuration. Also, depending on your system, 0.1 may crash if the probe is plugged into a usb3 port. Therefore I highly recommend building openocd from source. 2.2.1. Debian aarch32/64 Follow the openocd installation guide for the raspberry pi above, you may skip the spi details if you are not using a raspberry pi or you don’t want swd over spi support. Then start openocd with the configuration file for stlink. 2.2.2. Ubuntu Ubuntu is the most straightforward with building openocd. sudo apt install autoconf libtool libusb-1.0-0 libusb-1.0-0-dev # Dependencies. git clone --recursive https://github.com/ntfreak/openocd.git # Original openocd repo. cd openocd ./bootstrap ./configure make -j4 Upon success you will find an openocd binary in the src/ folder. Grab the configuration script stlink-swd.ocd presented above, connect your target to stlink and stlink to the host computer. sudo ./openocd -s ../tcl -f stlink-swd.ocd Argument -s ../tcl is a path to the tlc folder where openocd looks for configuration files; argument -f stlink-swd.ocd points to the session specific configuration we just created. Upon success you shall see a similar output: Info : clock speed 1000 kHz Info : STLINK V3J7M2 (API v3) Info : Target voltage: 3.3 ... Info : Listening on port 3333 for gdb connections 2.2.3. MacOS Unfortunately, openocd throws compilation errors on MacOS that I did not have motivation to resolve. The older version is available to install through brew install openocd, but it would not work with the newer stlink-v3. You are encouraged to troubleshoot the build and inform me on your findings. brew install autoconf libtool libusb git clone --recursive https://github.com/ntfreak/openocd.git # Original openocd repo. cd openocd ./bootstrap # Here you need to specify the paths to libusb. ./configure LIBUSB1_CFLAGS=-I/usr/local/Cellar/libusb/1.0.23/include/libusb-1.0 LIBUSB1_LIBS=-L/usr/local/Cellar/libusb/1.0.23/lib make -j4 Yet it is possible to debug with the latest stlink hardware on MacOS, proceed to 2.2.4 Workaround. 2.2.4. Workaround As a workaround you could scrape a pre built binary from STMCubeIDE. Tested on MacOS, should work on x86 Ubuntu and Windows. You’d have to download the STMCubeIDE package, but do not install it. Instead, extract and browse the package content, look for the following files. ST-LINK_gdbserver libSTLinkUSBDriver.dylib # .so on linux STM32_Programmer_CLI STLinkUpgrade.jar Copy your findings to a separate folder. The gdbserver executable looks for its libSTLinkUSBDriver library in a certain subfolder. Make sure your files are organized as in the following example for macos. . ├── ST-LINK_gdbserver ├── STLinkUpgrade.jar ├── STM32_Programmer_CLI └── native └── mac_x64 └── libSTLinkUSBDriver.dylib # .so on linux Otherwise you will get the following error. dyld: Library not loaded: @rpath/libSTLinkUSBDriver.dylib Connect the hardware. Now you can run the gdbserver as ./ST-LINK_gdbserver -e -d -cp . Uppon success you shall see ST-LINK device initialization OK Waiting for debugger connection... Waiting for connection on port 61234... Here -cp . is the path to STM32_Programmer_CLI, -d is for swd. If you look closer into the content of the STMCubeIDE package, you will find a config.txt in the folder with ST-LINK_gdbserver, which goes over all command line arguments ","date":"2020-11-26","objectID":"/embedded_debugging/:2:2","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"2.3. jlink Jlink comes with all software ready to go, get it from here. Look for JLinkGUIServerExe (warning gui), or JLinkGDBServerCLExe (command line). To avoid the gui prompts you need to provide enough arguments, described here. JLinkGDBServerCLExe -if swd -device stm32f103c8 Warning: jlink edu is painful to run on a remote server as it requires you to confirm the license agreement in a gui prompt at least once a day. In case you need to work with a remote jlink edu, use openocd instead. ","date":"2020-11-26","objectID":"/embedded_debugging/:2:3","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"3. gdb The GNU Debugger or gdb is a standard tool for debugging and hacking software in various languages written for various architectures; gdb allows tracing program execution by setting breakpoints, watching memories and processor states. The example presented in this tutorial is just a tiny glimpse of what gdb is capable of. You can debugg along with this empty initialization code for blue pill. Start with loading the firmware containing debug symbols. Most flavors of linux including Ubuntu have gdb installed by default. gdb blue-pill.elf In case you are on macos, the default system debugger is lldb. I use arm-none-eabi-gdb from the embedded arm toolchain package available here. Running gdb will welcome you into the debugger console, your command line output should be looking similar to the following. Reading symbols from blue-pill.elf... (gdb) Next, make sure your gdbserver (openocd or jlink) is running and listening for connections. If you are familiar with gdb, you may know that you can attach to a process running on the same machine. Since in bare metal scenario, the program being debugged is running on a physically different machine and and likely a different architecture, the gdb connection will always be “remote” even if the gdbserver is running on the same computer. The following command establishes connection with the gdbserver. Make sure your ip address and port matches the configuration. In case gdbserver is running on the same computer, you can put localhost instead of the ip address. The port depends on the gdbserver you are running, 3333 is default for openocd. (gdb) target extended-remote 192.168.1.24:3333 Issuing load will flash the firmware! (gdb) load Loading firmware does not reset the mcu, that is the program counter has not been set to the reset handler address. Issue a reset and halt. (gdb) monitor reset halt monitor \u003cexpression\u003e command sends the expression to gdbserver, gdb (client) itself does not know what reset halt does. step will progress the program counter to the next location. (gdb) step Look, we are exiting reset handler! Your output should be similar to the following. Reset_Handler () at /some_path/startup_stm32f103xb.s:66 Also, see how gdb knows Reset_Handler() is declared in startup_stm32f103xb.s line 66. Let’s set a breakpoint at the main function. (gdb) break main Referencing functions by name in gdb will only work with “global” functions. Let’s set a breakpoint in the infinite loop by referring to the corresponding line in file main.c. break main.c:96 To list all breakpoints type info break. Continue program execution. (gdb) continue This should take us to Breakpoint 1. Breakpoint 1, main () at /some_path/blue-pill/sources/src/main.c:74 list will display the proceeding lines of code following our current position. Here you could play with step and next, step will take you to the next program counter location, next – to the next function call. If you are familiar with debugging in any IDE, step is equivalent of “step in”, and next is “step out”. continue to get to our second breakpoint. You can delete all breakpoints by issuing delete or delete a specific breakpoint delete 1, or you can also disable breakpoints with disable. If there is no active breakpoints, issuing continue will continue executions until you manually stop it with ctrl+c – this halts execution of the debugee and does not exit gdb. There is so much to go on about gdb, we haven’t started with watchpoints, processor states and memory. Also, there is a python api that can help automate testing and hacking with gdb! ","date":"2020-11-26","objectID":"/embedded_debugging/:3:0","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"3.1. gdb + gui Many, if not all IDEs use gdb behind their visual interface. Now you can configure embedded debugging support in your favorite text editor. For instance if you use vscode, add a configuration file .vscode/launch.json in the project root. Make sure you have ms-vscode.cpptools extension. Here is my vscode debug configuration. // file: .vscode/launch.json { // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"configurations\": [ { \"name\": \"debug\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceRoot}/build/blue-pill.elf\", \"miDebuggerPath\": \"/Applications/ARM/bin/arm-none-eabi-gdb\", // \"debugServerPath\" and \"debugServerArgs\" are commands to start the gdbserver //\"debugServerPath\": \"/Applications/SEGGER/JLink_V662/JLinkGDBServerCLExe\", //\"debugServerArgs\": \"-device stm32l412cb -if swd\", \"cwd\": \"${workspaceRoot}\", \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Connect to gdbserver\", \"text\": \"target extended-remote 192.168.1.24:3333\" }, { \"description\": \"load executable\", \"text\": \"file ${workspaceRoot}/build/blue-pill.elf\" }, { \"description\": \"Flash Firmware\", \"text\": \"load\" }, { \"description\": \"Reset target\", \"text\": \"monitor reset halt\" }, ] } ] } ","date":"2020-11-26","objectID":"/embedded_debugging/:3:1","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"Afterword In case your favorite openocd repository is missing the latest stm configurations, you can check st’s openocd fork (configs are in tcl/ folder). Help Me Improve I am learning to write meaningful documentation. I hope you enjoyed this post, please help me back by emailing some feedback! Is information clear, correct and up to date? How would you improve this post? ","date":"2020-11-26","objectID":"/embedded_debugging/:4:0","tags":null,"title":"Embedded Debugging","uri":"/embedded_debugging/"},{"categories":null,"content":"Have you ever wondered what is going on behind the mystical IDE of your embedded choice? Many programming journeys start with learning user interface of a particular Development Environment – a path I took myself. While IDEs can arguably simplify things, various knobs get defaulted to some magic values. Unless you know upfront, it can be tricky to lookup what these radio buttons actually do. There is a plethora of bare-metal oriented Integrated Development Environments (IDEs) in the wild sharing a similar set of features. These include Keil, Atollic, IAR, mbed, a multitude of eclipse flavors, and well-known Arduino. This post/tutorial shows a method of developing embedded code without having a particular IDE in mind, a bare approach for bare metal development, underlining why IDE agnostic is elegant, efficient and simple. ","date":"2020-11-22","objectID":"/embedded_environment/:0:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"1. Requirements This post will focus on embedded ARM toolchain, particularly on the guidelines for the famous blue pill (aka stm32f103c8t6). The process is almost identical for other stm32 microcontrollers and simillar for embeded arm devices from other vendors (Atmel, NXP, etc). Further instructions are written for Unix platforms, that is Linux and MacOS. Our dependencies are gcc-arm-none-eabi – GNU ARM Embedded Toolchain. git – Version Control. CMake – Build System. ","date":"2020-11-22","objectID":"/embedded_environment/:1:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"1.1. gcc-arm-none-eabi Compiler, linker, debugger, objdump, you name it. Install using a package manager or from the arm website. Ubuntu sudo apt install gcc-arm-none-eabi MacOS brew install --cask gcc-arm-embedded ","date":"2020-11-22","objectID":"/embedded_environment/:1:1","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"1.2. git We will use git as a version control system and to pull some libraries into our project. Odds are you have git installed already, if unsure, try git --version. In case you don’t have git, follow installation instructions here. ","date":"2020-11-22","objectID":"/embedded_environment/:1:2","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"1.3. CMake CMake will serve us as a build system, it will generate tedious make files telling the compiler where to look for the source code and passing flags. CMake is the most widely spread build system, many IDEs rely on it. In fact, you don’t have to be familiar with CMake to follow this tutorial. Download CMake from here or install with a package manager. Ubuntu sudo apt install cmake MacOS brew install cmake ","date":"2020-11-22","objectID":"/embedded_environment/:1:3","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"2. Project Structure It all begins with creating a project directory, which will further be referenced as project root directory. mkdir blue-pill cd blue-pill Similarly to any software project, ours will have some code we write ourselves and some borrowed library code that will not change, except for when the libraries get updated. cmake directory will contain our build system. mkdir sources mkdir libraries mkdir cmake This is different from typical unix development, where your 3d party libraries are likely to live in /usr/local. Since we will be writing code for a different architecture we do not “install” libraries/headers into our system. ","date":"2020-11-22","objectID":"/embedded_environment/:2:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"3. Libraries ","date":"2020-11-22","objectID":"/embedded_environment/:3:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"3.1. CMSIS First, we are going to add Cortex Microcontroller Software Interface or CMSIS. There are traits all Cortex-M microcontrollers share. CMSIS serves as a standard, developed by ARM itself, to interface things like Nested Vector Interrupt Table (NVIC), Exception Handlers (Reset, Hard Fault, SysTick, Supervisor Call), Memory protection, Floating Point Unit, etc.. Here is a good article about exceptions and NVIC. Here is CMSIS github repository. In fact, all we will need in terms of the library support is available on git, therefore we can take use git submodule to link these repositories to our project. # From the project root. git init git submodule add https://github.com/ARM-software/CMSIS_5 libraries/CMSIS_5 cd libraries/CMSIS_5 git checkout master # The default branch is develop. cd ../.. # Back to the project root. Though cloning the entire CMSIS repo might be bulky, we only need a few headers. Imagine somebody else wants to build your project, fishing for headers can be extremely unpleasant. Another solution – some IDEs copy everything (cmsis and hal) into the project directory by default, which makes version control ugly, and does not allow to easily update libraries. We will also need the device specific CMSIS. This defines registers of the available peripherals. # From the project root. git submodule add https://github.com/STMicroelectronics/cmsis_device_f1.git libraries/cmsis_device_f1 ","date":"2020-11-22","objectID":"/embedded_environment/:3:1","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"3.2. HAL The next step is Hardware Abstraction Layer of the microcontroller peripherals. The blue pill has STM32F103C8T6 microcontroller, which brings us to ST’s github page where we find stm32f1xx_hal_driver. git submodule add https://github.com/STMicroelectronics/stm32f1xx_hal_driver.git libraries/stm32f1xx_hal_driver cd libraries/stm32f1xx_hal_driver Let’s be adventurous and screw a virtual com port to our project, because why not? The pill has usb support. git submodule add https://github.com/STMicroelectronics/stm32_mw_usb_device.git libraries/stm32_mw_usb_device cd libraries/stm32_mw_usb_device Virtual Com Port can be accessed from your computer the same way a generic serial port would, eliminating the need of usb to TTL converter, that is when you plug in your blue pill into a unix computer you can talk through /dev/tty.something. ","date":"2020-11-22","objectID":"/embedded_environment/:3:2","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"4. Sources Usually microcontroller vendors provide some template code to start off. Here I will use STM32CubeMX code generation tool. If you find using stm cube every time to generate initialization code painful, you need java to run it after all, make a template for a specific board and reuse it. For instance, the repository of this tutorial serves me as a template for the blue pill. Here is a checklist for stm cube. Access mcu selector -\u003e look for stm32f103c8. Pinout \u0026 Configuration: System Core -\u003e RCC -\u003e HSE = Crystal Resonator System Core -\u003e SYS -\u003e Debug = Serial Wire # I am using swd, you could use jtag. Connectivity -\u003e USB -\u003e Check Device Middleware -\u003e USB_DEVICE -\u003e Class = Communication device class (virtual com port) Optionally you could set PC13 to GPIO_Output to toggle the on-board led by clicking on the PC13 pin. Clock Configuration. To me this is the most appreciated part of stm cube, you get to see and play with clock settings without analyzing tens of data sheet pages. Blue pill has 8 MHz external oscillator, make sure you check that Input frequency = 8MHz PLL source mux is set to HSE System clock mux is PLL clock Play with different knobs, if you do something wrong cube will let you know. For instance usb frequency must always be set to 48MHz, if it’s different cube will raise the red flag. Though the maximum system frequency you can get is 72MHz, you can later modify it in the code (by accident), there is nothing that will stop you. Be warned, overclocking might be deadly. Project Manager. Project -\u003e Toolchain -\u003e SW4STM32 Code Generator -\u003e Check add necessary files as reference (this will prevent stm cube from copying all hal libraries into the project directory). Project -\u003e Project Name and Location: do not set our project root directory as the stm cube project location. When you open stm cube again in future, it can rewrite all the generated files, reorganizing and even deleting your changes. We should generate stm cube code to some temporary folder, then transfer the files manually. Often you would want to go back to stm cube and tweak the configuration. Generate Code. A side note on stm cube. The “firmware packages” that stm cube downloads to generate code contain lots of examples of peripherals initialization and usage. You can find these “firmware packages” at ~/STM32Cube/Repository/ or at ST’s github. Here is one for STM32F1xx family. Navigate to the folder where stm cube generated initialization code and copy Inc and Src folders to our sources directory. # Beware of your paths. cp -r Inc ~/projects/blue-pill/sources/inc cp -r Src ~/projects/blue-pill/sources/src # ps: I prefer lower case inc and src You might ask what about startup/? We already have a set of standard startup scripts in the libraries/stm32f1xx_hal_driver, which we will link later. ","date":"2020-11-22","objectID":"/embedded_environment/:4:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"5. CMake At this point we have summoned all sources in one place and are up to building a binary. Though we are building a hello world there is already a lot going on. The moment you supply power, processor exits reset state by setting the program counter to the predefined reset handler address – and here your code begins, or not quite yours, for this tutorial we will use startup code provided by st, but you are in full control. Back to cmake. Even though, cmake is much more human readable than make, we still have to deal with lots of tedious flags, which vary based on the microcontroller family. For instance, once I used to hardcode compiler flags into a line looking similar to this. # Not mentioning FPU flags.. set(COMMON_FLAGS \"-mcpu=cortex-m3 ${FPU_FLAGS} -mthumb -mthumb-interwork -ffunction-sections -fdata-sections -g -fno-common -fmessage-length=0 -specs=nosys.specs -specs=nano.specs -Os\")Let’s say one day you would like to switch to another microcontroller, now you have to update your build configuration, which as you see can be a bit tedious. Here I would like to introduce “yet another collection of cmake scripts” or yaccs, as inferred from its name yaccs contains some common build configurations and it supports embedded arm. # From project root. git submodule add https://github.com/nicocvn/yaccs.git cmake/yaccs Create a CMakeLists.txt in the project root with the following content. Credit goes to yaccs readme example. # file: CMakeLists.txt # This is required with modern version of CMake. cmake_minimum_required(VERSION 3.10)# Define the project. project(blue-pill ASM C CXX)add_executable(${PROJECT_NAME})# Linker Script set(LINKER_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/libraries/cmsis_device_f1/Source/Templates/gcc/linker/STM32F101XB_FLASH.ld)set_target_properties(${PROJECT_NAME} PROPERTIES SUFFIX \".elf\" LINK_OPTIONS \"-Wl,-gc-sections,--print-memory-usage,-Map=${PROJECT_NAME}.map,-T${LINKER_SCRIPT}\")# HAL libraries require to define target microcontroller. # See stm32f1xx.h for more details. target_compile_definitions(${PROJECT_NAME} PUBLIC -DSTM32F103xB -DUSE_HAL_DRIVER)# Include yaccs main CMake file. # This will automatically look and load the user-config file. # This has to be done before calling the project() command! include(cmake/yaccs/yaccs.cmake)# This is optional but useful to get a sense of what is happening. # This command will print various information about the build configuration. yaccs_system_info()# This is also optional but it helps by neatly organizing the build tree. yaccs_init_build_tree()# Add stuff from the sources directory. add_subdirectory(sources/)add_subdirectory(libraries/)Create yaccs-user-config.cmake in the project root, this will tell yaccs compiler location and which configuration to use. # file: yaccs-user-config.cmake # If the compiler is not in the PATH we need to tell yaccs where to find it. set(yaccs_compiler_paths /Applications/ARM/bin/)# Load the configuration. include(cmake/yaccs/cortex-m_gcc-arm_m3_cxx14.cmake)Tell cmake which sources to compile. With add_subdirectory statements, cmake looks for CMakeLists.txt in the specified directory, therefore we need to create one for sources and libraries. Create sources/CMakeLists.txt containing the following. # file: sources/CMakelists.txt # Add inc/ target_include_directories(${PROJECT_NAME} PUBLIC inc/)# Add src/ target_sources(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/src/main.c ${CMAKE_CURRENT_SOURCE_DIR}/src/stm32f1xx_it.c ${CMAKE_CURRENT_SOURCE_DIR}/src/usb_device.c ${CMAKE_CURRENT_SOURCE_DIR}/src/usbd_cdc_if.c ${CMAKE_CURRENT_SOURCE_DIR}/src/usbd_conf.c ${CMAKE_CURRENT_SOURCE_DIR}/src/usbd_desc.c)As you may notice we skipped syscalls.c generated by stmcube, this is because we are using a smaller version of the standard library, more on this here Create libraries/CMakeLists.txt. # file libraries/CMakelists.txt # List header locations. target_include_directories(${PROJECT_NAME} PUBLIC CMSIS_5/CMSIS/Core/Include cmsis_device_f","date":"2020-11-22","objectID":"/embedded_environment/:5:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"6. Build We are almost there. In case stm fixed this usb related bug, everything should compile. Make sure in function declarations USBD_LL_Transmit and USBD_LL_PrepareReceive the last function argument is uint32_t size and not uint16_t size. Finally comes the time to build the project. mkdir build cd build cmake .. make If you need to extract a binary blob (.bin or .hex), add following the CMakeLists.txt in the project root. # Extract binary blob set(HEX_FILE ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.hex)set(BIN_FILE ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.bin)add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Oihex $\u003cTARGET_FILE:${PROJECT_NAME}\u003e ${HEX_FILE} COMMAND ${CMAKE_OBJCOPY} -Obinary $\u003cTARGET_FILE:${PROJECT_NAME}\u003e ${BIN_FILE} COMMENT \"Extracting ${HEX_FILE}\\nExtracting ${BIN_FILE}\")","date":"2020-11-22","objectID":"/embedded_environment/:6:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"Afterword The final blue-pill template created in this tutorial is available here. A sequel on Embedded Debugging is available here. Help Me Improve I am learning to write meaningful documentation. I hope you enjoyed this post, please help me back by emailing some feedback! Is information clear, correct and up to date? How would you improve this post? ","date":"2020-11-22","objectID":"/embedded_environment/:7:0","tags":null,"title":"Embedded Environment","uri":"/embedded_environment/"},{"categories":null,"content":"About Me Hi. I identify as an engineer-scientist with a mixed background in computer science, electrical engineering, and physics. ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Sendyne Corp Currently employed at Sendyne Corp. where we work on research and development of various automotive grade sensors. Our work involves modeling, sensing, and control. Most of our code resembles python, modern C++, and occasionally javascript. ","date":"0001-01-01","objectID":"/about/:1:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"CCNY Robotics Lab Brought into the light working with the CCNY Robotics Lab. Here I prototyped robot architectures for various industrial inspection processes – from PCB and embedded firmware design to path planning algorithms. ","date":"0001-01-01","objectID":"/about/:1:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Personal When I am away form the keyboard and oscilloscope probes you can find me backpacking and social dancing (pre pandemic) ballroom, fusion/blues, and contact improv. ","date":"0001-01-01","objectID":"/about/:1:3","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Contact I am always open to connect, share, and explore with enthusiastic creatures. stanislav.sotnikov145[at]gmail[dot]com ","date":"0001-01-01","objectID":"/about/:1:4","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Credits Built with Hugo and LoveIt. ","date":"0001-01-01","objectID":"/about/:1:5","tags":null,"title":"","uri":"/about/"}]